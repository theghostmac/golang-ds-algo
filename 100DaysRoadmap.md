# Grinding DSA In Days
## Learn a Language
* [ ] Day 0:
    * [ ] Stick to a programming language like C or C++. Make sure that you are comfortable with pointers/objects.

## Time and Space Complexity
Understanding Algorithmic Complexity is very important at the Beginning, because without that we can’t decide 
which algorithm, data structure and logic is efficient and which is best for the particular problem.
* [ ] Day 1
    * [ ] Understand the concept of Algorithmic complexity. Skip the theory for now, but for every piece of code you write, you should be able to derive both time and space complexity.
## The Data Structures: Elementary - Advanced (Ingredients)
Data Structures are very important concepts in every programming language; just as a chef knows which and how 
many ingredients to use to prepare a delicious meal, like every programmer should know which data structures and 
inbuilt methods to use to construct a very efficient algorithm.
* [ ] Day 2 - 24: Let’s start with some simple data structures,
    * [ ] Day 2: Strings
    * [ ] Day 3: Arrays
    * [ ] Day 4: Linked List
    * [ ] Day 5: Stacks
    * [ ] Day 6: Queues
    * [ ] Day 7: HashMap
    * [ ] Day 8 - 10: HackerRank Grinding
    * [ ] Day 11 - 24: Understand their basic operations (insert, delete, search, traversal) and their complexity – Big-O Algorithm 
Complexity Cheat Sheet, and code them all.

## The Algorithm Usage (Tasty food)
In every area of programming, algorithms are crucial ideas. The way an algorithm is built utilizing data structures, 
a step-by-step methodology, and some effective logic is nothing like a great meal that one chef produces using 
some ingredients.

* [ ] Day 25 - 34: Sorting
    * [ ] Insertion sort
    * [ ] Merge sort
    * [ ] Quick sort
    * [ ] Heap sort
    * [ ] Bucket sort
    * [ ] Counting sort
    * [ ] Radix sort
    * [ ] External sorting
* [ ] Day 35 - 39: Search
  * [ ] Linear search
  * [ ] Binary Search 
  * [ ] (along with its variants).
* [ ] Day 40 - 42: Prime Numbers
  * [ ] Sieve of Eratosthenes
  * [ ] Primality test
* [ ] Day 43 - 45: Strings
  * [ ] String searching
  * [ ] LCS
  * [ ] Palindrome detection
* [ ] Day 46 - 51: Miscellaneous
  * [ ] Euclidean algorithm
  * [ ] Matrix multiplication
  * [ ] Fibonacci Numbers
  * [ ] Pascal's Triangle
  * [ ] Max Subarray problem

## The Problem Solver (Cook)
Day 51 - 100: Once you are comfortable with everything above, start doing problems from:
- Cracking the Coding Interview
- Elements of Programming Interviews
- Programming Interviews Exposed: Secrets to Landing Your Next Job
- GeeksforGeeks
- HackerRank
- InterviewBit

Stick to chapters of arrays, linked lists, strings, stacks, queues and complexity.

## Non-Linear Data Structures
* [ ] Day 52: Trees
  * [ ] Binary Tree
  * [ ] Binary Search Tree
  * [ ] Tree traversals
  * [ ] Lowest common ancestor
  * [ ] Depth, Height & Diameter
  * [ ] Finding k-th smallest element
* [ ] Day 54 - 60: Heaps
  * [ ] Hash table 
    * [ ] 4 sum problem
    * [ ] Checking if sudoku solution is valid
  * [ ] Graph
    * [ ] Breadth-first search
    * [ ] Depth-first search
    * [ ] Topological sorting
    * [ ] Minimum spanning tree
    * [ ] Shortest path problem

Day 61- 90: Refer to the previous resources and start doing problems from trees, hash tables, heaps and graphs.

Day 91 - 100: Understand Computational complexity theory and NP-completeness, Knapsack problem, Travelling salesman problem, SAT problem and so on.

Day 101 -  ∞ : You are now better than most of the CS undergrads. Keep revising the above topics and start competitive programming! Good luck!